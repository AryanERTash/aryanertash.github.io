<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="icon" href="InfoSarthi64.png" type="image/png">
  <title>InfoSarthi Chat</title>
  <style>
    :root {
      --bg: #0b0b0c;
      --panel: #0f1112;
      --muted: #9aa1a6;
      --accent: #7c4dff;
      --glass: rgba(255, 255, 255, 0.03);
      --radius: 16px;
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
      --monospace: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace
    }

    body {
      margin: 0;
      font-family: Inter, system-ui, Segoe UI, Roboto, "Helvetica Neue", Arial;
      background: var(--bg);
      color: #e6eef6
    }

    .app {
      display: flex;
      flex-direction: column;
      max-width: 900px;
      margin: 20px auto;
      padding: 16px;
      border-radius: 16px;
      background: var(--panel);
      box-shadow: var(--shadow);
      height: 95vh
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px
    }

    h1 {
      font-size: 18px;
      margin: 0
    }

    .history-list {
      background: var(--glass);
      padding: 12px;
      border-radius: 12px;
      max-height: 180px;
      overflow: auto;
      margin-bottom: 12px
    }

    .history-item {
      padding: 8px;
      border-radius: 10px;
      margin-bottom: 6px;
      cursor: pointer;
      border: 1px solid transparent
    }

    .history-item:hover {
      border-color: rgba(255, 255, 255, .03)
    }

    .messages {
      background: var(--glass);
      flex: 1;
      padding: 16px;
      border-radius: 12px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 12px
    }

    .message {
      max-width: 80%;
      padding: 12px;
      border-radius: 12px;
      line-height: 1.5;
      white-space: pre-wrap;
    }

    .message.user {
      align-self: flex-end;
      background: linear-gradient(180deg, rgba(255, 255, 255, .02), rgba(255, 255, 255, .01));
      border: 1px solid rgba(255, 255, 255, .03)
    }

    .message.assistant {
      align-self: flex-start;
      background: linear-gradient(180deg, rgba(255, 255, 255, .01), transparent);
      border: 1px solid rgba(255, 255, 255, .02);
      color: var(--muted)
    }

    .message.assistant.typing {
      position: relative
    }

    .message.assistant.typing::after {
      content: '|';
      animation: blink 1s infinite;
      color: var(--accent)
    }

    @keyframes blink {

      0%,
      50% {
        opacity: 1
      }

      100%,
      51% {
        opacity: 0
      }
    }

    textarea {
      flex: 1;
      border-radius: 12px;
      padding: 12px;
      background: 0 0;
      border: 1px solid rgba(255, 255, 255, .03);
      color: #fff;
      resize: vertical;
      min-height: 56px
    }

    .composer {
      display: flex;
      gap: 8px;
      align-items: end;
      margin-top: 8px
    }

    button.primary {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 10px 16px;
      border-radius: 12px;
      cursor: pointer
    }

    button.danger {
      background: 0 0;
      color: #ff7b7b;
      border: 1px solid rgba(255, 0, 0, .2);
      padding: 8px 12px;
      border-radius: 12px;
      cursor: pointer
    }

    kbd {
      padding: 6px 8px;
      border-radius: 8px;
      background: rgba(255, 255, 255, .02);
      border: 1px solid rgba(255, 255, 255, .02);
      font-family: var(--monospace);
      font-size: 12px
    }

    @media (max-width:840px) {
      .composer {
        flex-direction: column
      }
    }

    /* Markdown rendering */
    .message.assistant .markdown {
      color: #e6eef6;
    }

    .message.assistant .markdown table {
      border-collapse: collapse;
      width: 100%;
    }

    .message.assistant .markdown th,
    .message.assistant .markdown td {
      border: 1px solid rgba(255, 255, 255, 0.2);
      padding: 4px 8px;
    }

    .message.assistant canvas {
      margin-top: 12px;
      border-radius: 12px;
      background: rgba(255,255,255,0.05);
    }

    /* Chart container styling */
    .chart-container {
      position: relative;
      margin: 12px 0;
      border-radius: 12px;
      overflow: hidden;
      background: rgba(255,255,255,0.05);
      padding: 16px;
    }
    
    .chart-container canvas {
      width: 100% !important;
      height: 300px !important;
    }
    
    .chart-error {
      color: #ff7b7b;
      padding: 8px;
      border: 1px solid rgba(255,0,0,0.2);
      border-radius: 8px;
      margin: 8px 0;
    }
  </style>
</head>

<body>
  <div class="app">
    <header>
      <h1>InfoSarthi GroundWater Chat</h1>
      <button class="danger" id="clearHistory">Clear History</button>
    </header>
    <div class="history-list" id="historyList"></div>
    <div class="messages" id="messages"></div>
    <div class="composer">
      <textarea id="prompt" placeholder="Type a message... (Shift+Enter = newline)"></textarea>
      <button class="primary" id="sendBtn">Send</button>
    </div>
    <div style="margin-top:6px">
      <kbd>Enter = Send</kbd> <kbd>Shift+Enter = Newline</kbd>
    </div>
  </div>

  <!-- External libraries -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

  <script>
    const STORAGE_KEY = 'infosarthi.deepseek.chat';
    const messagesEl = document.getElementById('messages');
    const historyListEl = document.getElementById('historyList');
    const promptEl = document.getElementById('prompt');
    const sendBtn = document.getElementById('sendBtn');
    const clearHistoryBtn = document.getElementById('clearHistory');

    const API_KEY = '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';
    const MODEL = 'deepseek/deepseek-chat-v3.1';
    const ENDPOINT = 'https://openrouter.ai/api/v1/chat/completions';

    let history = loadHistory();
    let currentConversationId = history.length ? history[0].id : createConversation();
    renderHistory();
    loadConversation(currentConversationId);

    sendBtn.addEventListener('click', sendMessage);
    promptEl.addEventListener('keydown', e => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });
    clearHistoryBtn.addEventListener('click', () => {
      if (confirm('Clear all history?')) {
        history = [];
        saveHistory();
        renderHistory();
        messagesEl.innerHTML = '';
        currentConversationId = createConversation();
      }
    });

    function createId() { return 'c_' + Date.now().toString(36) + Math.random().toString(36).slice(2, 8); }
    function createConversation() {
      const conv = { id: createId(), messages: [], createdAt: Date.now() };
      history.unshift(conv);
      saveHistory();
      renderHistory();
      return conv.id;
    }
    function loadHistory() {
      try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]') } catch (e) { return []; }
    }
    function saveHistory() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(history));
      renderHistory();
    }
    function findConv(id) { return history.find(c => c.id === id); }
    function renderHistory() {
      historyListEl.innerHTML = '';
      if (!history.length) {
        historyListEl.innerHTML = '<div class="small" style="color:#9aa1a6">No conversations yet</div>';
        return;
      }
      history.forEach(c => {
        const item = document.createElement('div');
        item.className = 'history-item';
        item.tabIndex = 0;
        item.textContent = c.messages[0]?.content?.[0]?.text?.slice(0, 36) || 'New conversation';
        item.addEventListener('click', () => {
          currentConversationId = c.id;
          loadConversation(c.id);
        });
        historyListEl.appendChild(item);
      });
    }
    function loadConversation(id) {
      const conv = findConv(id);
      messagesEl.innerHTML = '';
      if (!conv || !conv.messages.length) {
        messagesEl.innerHTML = '<div class="small" style="color:#9aa1a6">No messages yet</div>';
        return;
      }
      conv.messages.forEach(m => renderMessage(m.role, m.content, false));
      messagesEl.scrollTop = messagesEl.scrollHeight;
    }

    function renderMessage(role, content, isTyping = false) {
      const el = document.createElement('div');
      el.className = 'message ' + role;
      if (isTyping) el.classList.add('typing');
      
      if (Array.isArray(content)) {
        content.forEach(c => {
          if (c.type === 'text') {
            renderMarkdown(el, c.text, isTyping);
          }
        });
      } else {
        renderMarkdown(el, content, isTyping);
      }
      messagesEl.appendChild(el);
      messagesEl.scrollTop = messagesEl.scrollHeight;
      return el;
    }

    function renderMarkdown(container, markdown, isTyping = false) {
      const html = marked.parse(markdown);
      const markdownDiv = document.createElement('div');
      markdownDiv.className = 'markdown';
      markdownDiv.innerHTML = html;
      
      // Clear container and add new markdown
      container.innerHTML = '';
      container.appendChild(markdownDiv);
      
      // Process chart code blocks if not typing
      if (!isTyping) {
        processChartCodeBlocks(markdownDiv);
      }
    }

    function processChartCodeBlocks(container) {
      // Find all code blocks that might contain chart code
      container.querySelectorAll('pre code').forEach((codeEl) => {
        const codeText = codeEl.textContent || codeEl.innerText;
        const parentPre = codeEl.closest('pre');
        
        // Check if this looks like Chart.js code
        if (codeText.includes('new Chart') || 
            codeText.includes('Chart.') || 
            codeEl.className.includes('chart') ||
            codeEl.className.includes('javascript') ||
            codeEl.className.includes('js')) {
          
          try {
            // Create container for the chart
            const chartContainer = document.createElement('div');
            chartContainer.className = 'chart-container';
            const canvas = document.createElement('canvas');
            chartContainer.appendChild(canvas);
            
            // Replace the entire pre element with our chart container
            parentPre.replaceWith(chartContainer);
            
            // Get the canvas context
            const ctx = canvas.getContext('2d');
            
            // Create a safe execution environment for the chart code
            const chartCode = `
              try {
                ${codeText}
              } catch(error) {
                console.error('Chart execution error:', error);
                throw error;
              }
            `;
            
            // Execute the chart code with proper context
            const executeChart = new Function('ctx', 'Chart', chartCode);
            executeChart(ctx, Chart);
            
          } catch (e) {
            console.error('Chart.js rendering error:', e);
            // Show error message
            const errorDiv = document.createElement('div');
            errorDiv.className = 'chart-error';
            errorDiv.innerHTML = `<strong>Chart Error:</strong> ${e.message}`;
            parentPre.replaceWith(errorDiv);
          }
        }
      });
    }

    function addMessage(role, content) {
      const conv = findConv(currentConversationId);
      conv.messages.push({ role, content, time: Date.now() });
      saveHistory();
      if (role === 'assistant') {
        renderTypingMessage(content);
      } else {
        renderMessage(role, content);
      }
    }

    function typeWriterMarkdown(element, text, speed = 10) {
      return new Promise(resolve => {
        let i = 0;
        element.innerHTML = '';
        element.classList.add('typing');
        
        function type() {
          i++;
          const current = text.slice(0, i);
          
          // Render markdown with the current text
          const html = marked.parse(current);
          const markdownDiv = document.createElement('div');
          markdownDiv.className = 'markdown';
          markdownDiv.innerHTML = html;
          
          // Clear and update element
          element.innerHTML = '';
          element.appendChild(markdownDiv);
          
          if (i < text.length) {
            setTimeout(type, speed);
          } else {
            element.classList.remove('typing');
            // Process chart code blocks after typing is complete
            processChartCodeBlocks(markdownDiv);
            resolve();
          }
        }
        type();
      });
    }
    
    function renderTypingMessage(content) {
      const el = document.createElement('div');
      el.className = 'message assistant';
      messagesEl.appendChild(el);
      let text = '';
      if (Array.isArray(content)) {
        content.forEach(c => { if (c.type === 'text') text += c.text + '\n'; });
      } else { text = content; }
      
      typeWriterMarkdown(el, text.trim()).then(() => {
        messagesEl.scrollTop = messagesEl.scrollHeight;
      });
    }

    async function sendMessage() {
      const text = promptEl.value.trim();
      if (!text) return;
      addMessage('user', [{ type: 'text', text: text }]);
      promptEl.value = '';

      const thinking = document.createElement('div');
      thinking.className = 'message assistant';
      thinking.textContent = 'Thinking…';
      messagesEl.appendChild(thinking);
      messagesEl.scrollTop = messagesEl.scrollHeight;

      try {
        let systemPrompt = `
You are a helpful assistant named InfoSarthi 🌊, specialized in groundwater data.

Guidelines:
- Be data-oriented 📊. Use numbers, facts, and references where possible.
- Use emojis to highlight key points and make responses engaging.
- Format your answers in Markdown.
- Whenever you want to visualize data, provide **Chart.js code snippets** with fetched datasets.
- Use bullet points, tables, or charts to organize data clearly.
- Keep explanations medium-length and concise.

Important: When creating charts, use the following format:
\`\`\`javascript
// Your Chart.js code here
// Use 'ctx' as the canvas context variable and 'Chart' as the library
// Example of a working chart:
const chart = new Chart(ctx, {
  type: 'bar',
  data: {
    labels: ['January', 'February', 'March', 'April', 'May'],
    datasets: [{
      label: 'Groundwater Level (meters)',
      data: [12.5, 11.8, 10.2, 9.5, 8.7],
      backgroundColor: 'rgba(124, 77, 255, 0.7)',
      borderColor: 'rgba(124, 77, 255, 1)',
      borderWidth: 1
    }]
  },
  options: {
    responsive: true,
    plugins: {
      title: {
        display: true,
        text: 'Monthly Groundwater Levels'
      },
      legend: {
        display: true,
        position: 'top'
      }
    },
    scales: {
      y: {
        beginAtZero: false,
        title: {
          display: true,
          text: 'Water Level (meters)'
        }
      },
      x: {
        title: {
          display: true,
          text: 'Month'
        }
      }
    }
  }
});
\`\`\`

Make sure your chart code:
1. Uses 'ctx' as the canvas context
2. Uses 'Chart' as the library (not 'chart' or other variables)
3. Includes proper configuration with data and options
4. Uses valid Chart.js syntax
        `;

        const conv = findConv(currentConversationId);
        const apiMessages = [
          { role: 'system', content: systemPrompt },
          ...conv.messages.map(m => ({
            role: m.role,
            content: Array.isArray(m.content)
              ? m.content.map(c => c.text).join('\n')
              : m.content
          }))
        ];

        const body = { model: MODEL, messages: apiMessages, temperature: 0.7 };

        const resp = await fetch(ENDPOINT, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${API_KEY}`,
            'Content-Type': 'application/json',
            'HTTP-Referer': window.location.href,
            'X-Title': 'InfoSarthi GroundWater Chat'
          },
          body: JSON.stringify(body)
        });

        if (!resp.ok) {
          const errorText = await resp.text();
          throw new Error(`HTTP ${resp.status}: ${errorText}`);
        }

        const data = await resp.json();
        const assistantContent = data?.choices?.[0]?.message?.content || '[No response]';

        thinking.remove();
        addMessage('assistant', [{ type: 'text', text: assistantContent }]);

      } catch (e) {
        thinking.remove();
        addMessage('assistant', [{ type: 'text', text: 'Error: ' + e.message }]);
      }
    }
  </script>
</body>

</html>