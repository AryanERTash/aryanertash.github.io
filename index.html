<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>InfoSarthi Chat</title>
	<link rel="icon" href="InfoSarthi64.png" type="image/png">
	<style>
		:root {
			--bg: #0b0b0c;
			--panel: rgba(15, 17, 18, 0.95);
			--muted: #9aa1a6;
			--accent: #7c4dff;
			--glass: rgba(255, 255, 255, 0.05);
			--radius: 16px;
			--shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
			--font: 'Inter', system-ui, sans-serif;
		}

		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		body {
			font-family: var(--font);
			background: var(--bg);
			color: #e6eef6;
			display: flex;
			justify-content: center;
			align-items: center;
			height: 100vh;
			padding: 10px;
		}

		.app {
			display: flex;
			flex-direction: column;
			width: 100%;
			max-width: 900px;
			height: 95vh;
			background: var(--panel);
			border-radius: var(--radius);
			box-shadow: var(--shadow);
			overflow: hidden;
		}

		header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			padding: 16px 24px;
			backdrop-filter: blur(10px);
			background: var(--glass);
			border-bottom: 1px solid rgba(255, 255, 255, 0.1);
		}

		header h1 {
			font-size: 1.4rem;
			display: flex;
			align-items: center;
			gap: 12px;
		}

		header img {
			height: 40px;
			border-radius: 50%;
		}

		header button {
			background: var(--accent);
			color: #fff;
			border: none;
			padding: 8px 16px;
			border-radius: 12px;
			cursor: pointer;
		}

		header button:hover {
			background: #925aff;
		}

		.messages {
			flex: 1;
			padding: 16px;
			overflow-y: auto;
			display: flex;
			flex-direction: column;
			gap: 16px;
			/* Increased for more space */
			background: rgba(255, 255, 255, 0.03);
			backdrop-filter: blur(5px);
		}

		.message {
			max-width: 75%;
			padding: 12px 16px;
			border-radius: var(--radius);
			line-height: 1.5;
			/* FIX 1: Ensure text wraps correctly and respects max-width */
			word-wrap: break-word;
			overflow-wrap: break-word;
			position: relative;
			box-sizing: border-box;
		}

		.message.user {
			align-self: flex-end;
			background: linear-gradient(145deg, #6b5bff, #7c4dff);
			color: #fff;
			border-bottom-right-radius: 0;
		}

		.message.assistant {
			align-self: flex-start;
			background: var(--glass);
			border: 1px solid rgba(255, 255, 255, 0.1);
			color: var(--muted);
			border-bottom-left-radius: 0;
			display: flex;
			gap: 10px;
			align-items: flex-start;
			max-width: 95%;
			/* FIX 2: Allow the markdown content to take available space */
			min-width: 0;
		}

		.message.assistant img {
			width: 30px;
			height: 30px;
			border-radius: 50%;
			flex-shrink: 0;
		}

		.message.assistant .markdown {
			/* FIX 3: Ensure the markdown container expands correctly and wraps content */
			width: 100%;
			min-width: 0;
		}

		.typing-dots {
			display: flex;
			gap: 5px;
			align-items: center;
		}

		.dot {
			width: 6px;
			height: 6px;
			background: var(--accent);
			border-radius: 50%;
			animation: bounce 1s infinite;
		}

		.dot:nth-child(2) {
			animation-delay: 0.2s;
		}

		.dot:nth-child(3) {
			animation-delay: 0.4s;
		}

		@keyframes bounce {

			0%,
			80%,
			100% {
				transform: scale(0);
			}

			40% {
				transform: scale(1);
			}
		}

		.composer-wrapper {
			display: flex;
			flex-direction: column;
		}

		.suggested-queries {
			display: flex;
			flex-wrap: wrap;
			gap: 8px;
			padding: 8px 16px;
			background: rgba(255, 255, 255, 0.05);
			border-top: 1px solid rgba(255, 255, 255, 0.1);
		}

		.query {
			background: rgba(124, 77, 255, 0.2);
			color: #fff;
			padding: 6px 12px;
			border-radius: 12px;
			cursor: pointer;
			transition: 0.2s;
			font-size: 0.9rem;
		}

		.query:hover {
			background: rgba(124, 77, 255, 0.4);
		}

		.composer {
			display: flex;
			padding: 12px 16px;
			gap: 10px;
			backdrop-filter: blur(10px);
			background: var(--glass);
			border-top: 1px solid rgba(255, 255, 255, 0.1);
		}

		.composer textarea {
			flex: 1;
			border-radius: var(--radius);
			border: 1px solid rgba(255, 255, 255, 0.1);
			padding: 12px;
			background: rgba(255, 255, 255, 0.02);
			color: #fff;
			resize: none;
			min-height: 50px;
		}

		.composer button {
			background: var(--accent);
			color: #fff;
			border: none;
			padding: 12px 18px;
			border-radius: var(--radius);
			cursor: pointer;
			transition: 0.2s;
		}

		.composer button:disabled {
			background: rgba(124, 77, 255, 0.4);
			cursor: not-allowed;
		}

		/* Styles for markdown content */
		.markdown {
			word-wrap: break-word;
			overflow-wrap: break-word;
			min-width: 0;
		}

		.markdown p {
			margin-bottom: 1em;
			/* Increased for more space */
		}

		.markdown ul,
		.markdown ol {
			padding-left: 20px;
			margin-bottom: 1em;
			/* Increased for more space */
		}

		.markdown code {
			background: rgba(0, 0, 0, 0.3);
			padding: 2px 4px;
			border-radius: 4px;
			font-family: monospace;
		}

		.markdown pre {
			/* FIX 4: Prevent code block from causing horizontal overflow */
			max-width: 100%;
			background: rgba(0, 0, 0, 0.3);
			padding: 10px;
			border-radius: 8px;
			overflow-x: auto;
		}

		.markdown pre code {
			background: none;
			padding: 0;
		}

		.markdown table {
			border-collapse: collapse;
			width: 100%;
			margin: 1em 0;
		}

		.markdown th,
		.markdown td {
			border: 1px solid rgba(255, 255, 255, 0.2);
			padding: 6px 12px;
		}

		.markdown th {
			background: rgba(255, 255, 255, 0.1);
		}

		.chart-container {
			margin-top: 12px;
			border-radius: 12px;
			overflow: hidden;
			background: rgba(255, 255, 255, 0.05);
			padding: 16px;
			max-width: 100%;
			/* Ensure it respects parent width */
		}

		.chart-container canvas {
			width: 100% !important;
			height: 300px !important;
		}

		.chart-error {
			color: #ff7b7b;
			padding: 8px;
			border: 1px solid rgba(255, 0, 0, 0.2);
			border-radius: 8px;
			margin: 8px 0;
		}
	</style>
</head>

<body>
	<div class="app">
		<header>
			<h1><img src="InfoSarthi64.png" alt="Logo"> InfoSarthi GroundWater</h1>
			<button id="clearHistory">Clear History</button>
		</header>

		<div class="messages" id="messages"></div>

		<div class="composer-wrapper">
			<div class="suggested-queries" id="suggestedQueries">
				<span class="query">Maharashtra groundwater 2024-2025</span>
				<span class="query">Most critical regions of India</span>
				<span class="query">Delhi critical groundwater zones</span>
			</div>
			<div class="composer">
				<textarea id="prompt" placeholder="Type a message..."></textarea>
				<button id="sendBtn">â†‘</button>
			</div>
		</div>
	</div>

	<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
	<script>
		// --- API Configuration ---
		const a = "sk-or-v1-3f50192b1530997d30dc90d2540e592f3cb83aa3";
		const b = "f8e8fee8353f188949021383";
		const API_KEY = a + b;
		const MODEL = 'deepseek/deepseek-chat-v3.1';
		const ENDPOINT = 'https://openrouter.ai/api/v1/chat/completions';
		const WORD_DELAY = 10; // ms delay per word for streaming effect
		let systemPrompt = `
You are a helpful assistant named InfoSarthi ðŸŒŠ, specialized in groundwater data.

Guidelines:
- Be data-oriented ðŸ“Š. Use numbers, facts, and references where possible.
- Use emojis to highlight key points and make responses engaging.
- Format your answers in Markdown.
- Whenever you want to visualize data, provide **Chart.js code snippets** with fetched datasets.
- Use bullet points, tables, or charts to organize data clearly.
- Keep explanations medium-length and concise.
- Also give any other info if user demand.
- keep is short and to the point


Important: When creating charts , use the following format:
\`\`\`javascript
// Your Chart.js code here
// Use 'ctx' as the canvas context variable and 'Chart' as the library
// Example of a working chart (a charts can be based on any thing ):
const chart = new Chart(ctx, {
  type: 'bar',
  data: {
    labels: ['January', 'February', 'March', 'April', 'May'],
    datasets: [{
      label: 'Groundwater Level (meters)',
      data: [12.5, 11.8, 10.2, 9.5, 8.7],
      backgroundColor: 'rgba(124, 77, 255, 0.7)',
      borderColor: 'rgba(124, 77, 255, 1)',
      borderWidth: 1
    }]
  },
  options: {
    responsive: true,
    plugins: {
      title: {
        display: true,
        text: 'Monthly Groundwater Levels'
      },
      legend: {
        display: true,
        position: 'top'
      }
    },
    scales: {
      y: {
        beginAtZero: false,
        title: {
          display: true,
          text: 'Water Level (meters)'
        }
      },
      x: {
        title: {
          display: true,
          text: 'Month'
        }
      }
    }
  }
});
\`\`\`

Make sure your chart code:
1. Uses 'ctx' as the canvas context
2. Uses 'Chart' as the library (not 'chart' or other variables)
3. Includes proper configuration with data and options
4. Uses valid Chart.js syntax
        `;

		// --- DOM Elements ---
		const messagesEl = document.getElementById('messages');
		const promptEl = document.getElementById('prompt');
		const sendBtn = document.getElementById('sendBtn');
		const clearBtn = document.getElementById('clearHistory');
		const suggestedQueriesEl = document.getElementById('suggestedQueries');

		// --- Chat State & Storage ---
		const STORAGE_KEY = 'infosarthi.chat';
		let chatData = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');

		function saveChat() {
			localStorage.setItem(STORAGE_KEY, JSON.stringify(chatData));
		}

		function renderMessages() {
			messagesEl.innerHTML = '';
			chatData.forEach(m => renderMessage(m.role, m.text));
			messagesEl.scrollTop = messagesEl.scrollHeight;
		}

		// --- Message Rendering ---

		/**
		 * Renders a message instantly (used for chat history and user messages).
		 */
		function renderMessage(role, text) {
			const el = document.createElement('div');
			el.className = 'message ' + role;

			if (role === 'assistant') {
				const markdownDiv = document.createElement('div');
				markdownDiv.className = 'markdown';
				// Use DOMPurify for sanitization in a real-world app
				markdownDiv.innerHTML = marked.parse(text, { breaks: true });

				el.innerHTML = `<img src="InfoSarthi64.png" alt="bot">`;
				el.appendChild(markdownDiv);
				messagesEl.appendChild(el);

				processChartBlocks(markdownDiv);
			} else {
				el.textContent = text;
				messagesEl.appendChild(el);
			}
			messagesEl.scrollTop = messagesEl.scrollHeight;
		}

		/**
		 * Renders a response with a word-by-word streaming effect.
		 * Charts are rendered immediately when their code block is encountered.
		 */
		async function renderStreamedResponse(fullText, markdownDiv) {
			// Regex to split text by chart blocks, keeping the delimiters
			const parts = fullText.split(/(\`\`\`javascript[\s\S]*?\`\`\`)/g);
			let currentMarkdown = '';

			for (const part of parts) {
				if (!part) continue;

				if (part.startsWith('```javascript')) {
					// It's a chart block, render the *entire* block's text at once
					currentMarkdown += part;
					markdownDiv.innerHTML = marked.parse(currentMarkdown, { breaks: true });

					// Process charts immediately after parsing
					processChartBlocks(markdownDiv);
					messagesEl.scrollTop = messagesEl.scrollHeight;
					// Add a slight delay for better visual separation before the next text block
					await new Promise(resolve => setTimeout(resolve, 50));

				} else {
					// It's a text block, stream it word by word
					const words = part.split(/(\s+)/); // Split while preserving spaces
					for (const word of words) {
						if (word.length > 0) {
							currentMarkdown += word;
							// Re-parse the cumulative markdown string
							markdownDiv.innerHTML = marked.parse(currentMarkdown, { breaks: true });
							messagesEl.scrollTop = messagesEl.scrollHeight;
							await new Promise(resolve => setTimeout(resolve, WORD_DELAY));
						}
					}
				}
			}
			// Final parse and process to ensure everything is correct
			markdownDiv.innerHTML = marked.parse(fullText, { breaks: true });
			processChartBlocks(markdownDiv);
			messagesEl.scrollTop = messagesEl.scrollHeight;
		}


		function processChartBlocks(container) {
			container.querySelectorAll('pre code').forEach(codeEl => {
				// Check if the language is javascript and it contains Chart.js keywords
				if (codeEl.className.includes('language-javascript') && codeEl.textContent.includes('new Chart')) {
					const parent = codeEl.closest('pre');

					// FIX 5: Prevent re-processing and ensure chart is processed only once
					if (parent.dataset.processedChart) {
						return;
					}
					parent.dataset.processedChart = true; // Mark as processed

					const div = document.createElement('div');
					div.className = 'chart-container';
					const canvas = document.createElement('canvas');
					div.appendChild(canvas);

					// FIX 6: Hide the original code block
					parent.style.display = 'none';

					// Insert the chart container *after* the code block
					parent.insertAdjacentElement('afterend', div);

					try {
						// Execute the chart code
						// The Function constructor provides a cleaner execution environment
						new Function('ctx', 'Chart', codeEl.textContent)(canvas.getContext('2d'), Chart);
					} catch (e) {
						console.error('Chart.js Error:', e);
						div.innerHTML = `<div class="chart-error"><strong>Chart Error:</strong> ${e.message}</div>`;
						// If it fails, show the code block again for debugging
						parent.style.display = 'block';
					}
				}
			});
		}

		/**
		 * Adds a message to chatData and renders it (for user messages).
		 */
		function addMessage(role, text) {
			chatData.push({ role, text });
			saveChat();
			renderMessage(role, text);
		}

		// --- Send Message (API Integration) ---
		async function sendMessage() {
			const text = promptEl.value.trim();
			if (!text) return;

			addMessage('user', text); // Renders user message instantly
			promptEl.value = '';
			sendBtn.disabled = true;

			// Add typing indicator
			const typingEl = document.createElement('div');
			typingEl.className = 'message assistant';
			typingEl.innerHTML = `<img src="InfoSarthi64.png" alt="bot"><div class="typing-dots"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>`;
			messagesEl.appendChild(typingEl);
			messagesEl.scrollTop = messagesEl.scrollHeight;

			// Prepare payload for API
			const messagesPayload = [
				{ role: 'system', content: systemPrompt },
				// Map only the history, not the new user message again
				...chatData.filter(m => m.role !== 'system').slice(0, -1).map(m => ({ role: m.role, content: m.text })),
				{ role: 'user', content: text } // Add the latest user text
			];

			try {
				const response = await fetch(ENDPOINT, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						'Authorization': `Bearer ${API_KEY}`,
						'HTTP-Referer': window.location.href,
						'X-Title': 'InfoSarthi Chat'
					},
					body: JSON.stringify({
						model: MODEL,
						messages: messagesPayload,
						stream: false
					})
				});

				if (!response.ok) {
					const errData = await response.json();
					throw new Error(errData.error.message || `HTTP error! status: ${response.status}`);
				}

				const data = await response.json();
				const replyText = data.choices[0].message.content;

				// Remove typing indicator
				typingEl.remove();

				// Add assistant reply to history
				chatData.push({ role: 'assistant', text: replyText });
				saveChat();

				// Create new message elements for streaming
				const el = document.createElement('div');
				el.className = 'message assistant';
				const markdownDiv = document.createElement('div');
				markdownDiv.className = 'markdown';
				el.innerHTML = `<img src="InfoSarthi64.png" alt="bot">`;
				el.appendChild(markdownDiv);
				messagesEl.appendChild(el);
				messagesEl.scrollTop = messagesEl.scrollHeight;

				// Start the streaming render
				await renderStreamedResponse(replyText, markdownDiv);

			} catch (error) {
				console.error('API Error:', error);
				typingEl.remove();
				// Show error message in chat (using the non-streaming renderMessage)
				const errorText = `**Error:**\n\nI'm sorry, I encountered a problem: ${error.message}`;
				chatData.push({ role: 'assistant', text: errorText });
				saveChat();
				renderMessage('assistant', errorText);
			} finally {
				sendBtn.disabled = false;
				promptEl.focus();
			}
		}

		// --- Event Listeners ---
		sendBtn.addEventListener('click', sendMessage);
		promptEl.addEventListener('keydown', e => {
			if (e.key === 'Enter' && !e.shiftKey) {
				e.preventDefault();
				sendMessage();
			}
		});

		clearBtn.addEventListener('click', () => {
			if (confirm('Are you sure you want to clear the chat history?')) {
				chatData = [];
				saveChat();
				renderMessages();
			}
		});

		suggestedQueriesEl.addEventListener('click', e => {
			if (e.target.classList.contains('query')) {
				promptEl.value = e.target.textContent;
				sendMessage();
			}
		});

		// Initial render of chat history on load
		renderMessages();
	</script>
</body>

</html>